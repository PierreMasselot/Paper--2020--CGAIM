dlag <- function(x, lags = 1, na.action = na.pass)  #! ADD TIME INDEX
# x: vector of data to lag
# lags: vector of lags to apply
# na.action: action for the NAs generated by the lagging
{
    n <- length(x)
    L <- length(lags)
    maxlag <- max(lags)
    res <- matrix(NA, n, L)
    for (j in 1:L){
        lj <- lags[j]
        res[(lj+1):n,j] <- x[1:(n-lj)]
    }
    res <- do.call(na.action, list(res))
    return(res)
}

fscaling <- function(x, a = 0, b = 1){
  xsc <- (x - min(x, na.rm = T)) / diff(range(x, na.rm = T))
  xsc <- a + (xsc * (b - a))
  return(xsc)
}

#' Make a color transparent
#'
#' Takes a color and returns the same color but with transparency.
#'
#' @param col Vector of any of the three kinds of R color specifications, see
#'    \code{\link[grDevices]{col2rgb}}.
#' @param alpha Numeric vector of values between 0 and 1 giving the transparency
#'    ratios for each color. Note that this is inversed compared to the 
#'    \code{alpha} parameter in \code{\link[grDevices]{rgb}}, \emph{i.e.} 
#'    \code{alpha = 0} means opaque and \code{alpha = 1} fully transparent.
#'
#' @return A vector of colors in hexadecimal specification. See 
#'    \code{\link[grDevices]{rgb}}. 
transparency <- function(col, alpha = 0){
  rgb.val <- col2rgb(col)
  transp.col <- apply(rgb.val, 2, function(x){
    rgb(x[1], x[2], x[3], max = 255, 
      alpha = (1 - alpha) * 255)
  })
  return(transp.col)
}