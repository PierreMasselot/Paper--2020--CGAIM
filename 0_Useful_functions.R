dlag <- function(x, lags = 1, na.action = na.pass)  #! ADD TIME INDEX
# x: vector of data to lag
# lags: vector of lags to apply
# na.action: action for the NAs generated by the lagging
{
    n <- length(x)
    L <- length(lags)
    maxlag <- max(lags)
    res <- matrix(NA, n, L)
    for (j in 1:L){
        lj <- lags[j]
        res[(lj+1):n,j] <- x[1:(n-lj)]
    }
    res <- do.call(na.action, list(res))
    return(res)
}

fscaling <- function(x, a = 0, b = 1){
  xsc <- (x - min(x, na.rm = T)) / diff(range(x, na.rm = T))
  xsc <- a + (xsc * (b - a))
  return(xsc)
}

#' Make a color transparent
#'
#' Takes a color and returns the same color but with transparency.
#'
#' @param col Vector of any of the three kinds of R color specifications, see
#'    \code{\link[grDevices]{col2rgb}}.
#' @param alpha Numeric vector of values between 0 and 1 giving the transparency
#'    ratios for each color. Note that this is inversed compared to the 
#'    \code{alpha} parameter in \code{\link[grDevices]{rgb}}, \emph{i.e.} 
#'    \code{alpha = 0} means opaque and \code{alpha = 1} fully transparent.
#'
#' @return A vector of colors in hexadecimal specification. See 
#'    \code{\link[grDevices]{rgb}}. 
transparency <- function(col, alpha = 0){
  rgb.val <- col2rgb(col)
  transp.col <- apply(rgb.val, 2, function(x){
    rgb(x[1], x[2], x[3], max = 255, 
      alpha = (1 - alpha) * 255)
  })
  return(transp.col)
}


axis.intervals <- function(side=1, ticks = axTicks(side), atLabels = NULL, labels = 1:length(atLabels), ...)
{
    stopifnot((side <- as.integer(side)) %in% 1:4)
    if (length(ticks) == 1){
       is.x <- side%%2 == 1
       usr <- par("usr")[1:2 + 2*!is.x]
       XY <- function(ch) paste0(if (is.x) "x" else "y", ch)
       axs <- par(XY("axs"))
       if (axs == "r"){
          per4 <- 4*diff(usr)/108
          usr[1] <- usr[1] + per4
          usr[2] <- usr[2] - per4
       }
       nIntervals <- floor(ticks)
       ticks <- seq(usr[1],usr[2],length.out = nIntervals + 1)
    } else {
       nIntervals <- length(ticks) - 1
    }    
    axis(side, at = ticks, labels = FALSE, ...)
    if (is.null(atLabels)){
       atLabels <- (ticks[-1] + ticks[1:nIntervals]) / 2
    } else {
       if (length(atLabels) != nIntervals) atLabels <- rep_len(atLabels,nIntervals)
    }
    if (length(labels) != nIntervals) labels <- rep_len(labels,nIntervals)
    axis(side, at = atLabels, labels = labels, tick = FALSE, ...)
}